/**
 * SQL generator orchestrator
 * Main entry point for generating all SQL from schemas
 */

import { generateCreateTable, generateDropTable } from './table-generator.js';
import { generateIndexes } from './index-generator.js';
import { generateForeignKeys, generateCheckConstraints, generateUniqueConstraints } from './constraint-generator.js';

/**
 * Generate all SQL for a single schema
 * @param {object} schema - Table schema
 * @param {object} options - Generation options
 * @returns {object} Generated SQL statements
 */
export function generateSQL(schema, options = {}) {
  const sql = {
    table: generateCreateTable(schema),
    indexes: generateIndexes(schema),
    constraints: generateForeignKeys(schema),
    checkConstraints: generateCheckConstraints(schema),
    uniqueConstraints: generateUniqueConstraints(schema)
  };

  // If force mode, include DROP statements
  if (options.force) {
    sql.drop = generateDropTable(schema.table, true);
  }

  return sql;
}

/**
 * Generate all SQL for multiple schemas
 * @param {object[]} schemas - Array of schemas
 * @param {object} options - Generation options
 * @returns {object[]} Array of generated SQL for each schema
 */
export function generateAllSQL(schemas, options = {}) {
  return schemas.map(schema => ({
    table: schema.table,
    source: schema._metadata?.source || 'unknown',
    sql: generateSQL(schema, options)
  }));
}

/**
 * Generate a complete SQL migration file content
 * @param {object[]} schemas - Array of schemas
 * @param {object} options - Generation options
 * @returns {string} Complete SQL file content
 */
export function generateMigrationFile(schemas, options = {}) {
  const lines = [];

  lines.push('-- Generated by database-tools');
  lines.push(`-- Date: ${new Date().toISOString()}`);
  lines.push('-- DO NOT EDIT THIS FILE MANUALLY\n');

  // Drop tables if force mode
  if (options.force) {
    lines.push('-- DROP TABLES');
    for (const schema of schemas.reverse()) {
      lines.push(generateDropTable(schema.table, true));
    }
    schemas.reverse(); // Restore original order
    lines.push('');
  }

  // Create tables
  lines.push('-- CREATE TABLES');
  for (const schema of schemas) {
    lines.push(`-- ${schema.table} (${schema._metadata?.source || 'unknown'})`);
    lines.push(generateCreateTable(schema));
    lines.push('');
  }

  // Create indexes
  lines.push('-- CREATE INDEXES');
  for (const schema of schemas) {
    const indexes = generateIndexes(schema);
    if (indexes.length > 0) {
      lines.push(`-- Indexes for ${schema.table}`);
      lines.push(...indexes);
      lines.push('');
    }
  }

  // Create constraints
  if (!options.skipConstraints) {
    // Foreign key constraints
    lines.push('-- CREATE FOREIGN KEY CONSTRAINTS');
    for (const schema of schemas) {
      const constraints = generateForeignKeys(schema);
      if (constraints.length > 0) {
        lines.push(`-- Foreign keys for ${schema.table}`);
        lines.push(...constraints);
        lines.push('');
      }
    }

    // CHECK constraints
    lines.push('-- CREATE CHECK CONSTRAINTS');
    for (const schema of schemas) {
      const checkConstraints = generateCheckConstraints(schema);
      if (checkConstraints.length > 0) {
        lines.push(`-- Check constraints for ${schema.table}`);
        lines.push(...checkConstraints);
        lines.push('');
      }
    }

    // UNIQUE constraints
    lines.push('-- CREATE UNIQUE CONSTRAINTS');
    for (const schema of schemas) {
      const uniqueConstraints = generateUniqueConstraints(schema);
      if (uniqueConstraints.length > 0) {
        lines.push(`-- Unique constraints for ${schema.table}`);
        lines.push(...uniqueConstraints);
        lines.push('');
      }
    }
  }

  return lines.join('\n');
}

/**
 * Count total SQL statements
 * @param {object[]} allSQL - Array of SQL results from generateAllSQL
 * @returns {object} Counts by type
 */
export function countStatements(allSQL) {
  let tables = 0;
  let indexes = 0;
  let foreignKeys = 0;
  let checkConstraints = 0;
  let uniqueConstraints = 0;

  for (const item of allSQL) {
    if (item.sql.table) tables++;
    indexes += item.sql.indexes.length;
    foreignKeys += item.sql.constraints.length;
    checkConstraints += (item.sql.checkConstraints || []).length;
    uniqueConstraints += (item.sql.uniqueConstraints || []).length;
  }

  return {
    tables,
    indexes,
    foreignKeys,
    checkConstraints,
    uniqueConstraints,
    constraints: foreignKeys + checkConstraints + uniqueConstraints
  };
}
