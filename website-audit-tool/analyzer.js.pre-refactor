import { chromium } from 'playwright';
import Anthropic from '@anthropic-ai/sdk';
import dotenv from 'dotenv';
import { promises as fs } from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import { discoverPages } from './modules/crawler.js';
import { detectIndustry, getIndustryBestPractices } from './modules/industry.js';
import { runSEOAudit, formatSEOResultsForAI } from './modules/seo.js';
import { analyzeVisualDesign, formatVisualResultsForAI } from './modules/visual.js';
import { discoverAndAnalyzeCompetitors } from './modules/competitor.js';
import { buildAnalysisPrompt, buildContentSection } from './modules/prompt-builder.js';
import { parseJSONFromText } from './modules/ai-utils.js';
import { createDraft } from './modules/drafts-gmail.js';
import { extractFromPage, findBestContact } from './modules/contact.js';
import { sanitizeHumanizedEmail, replacePlaceholders } from './modules/email-sanitizer.js';
import { callAI, MODELS } from './ai-providers.js';
import { validateJSON, formatValidationResult, validateQualityWithAI } from './modules/json-validator.js';
import { extractWithGrok, getBestContactEmail, getBestContactPerson, getMostRecentPost } from './modules/grok-extractor.js';
import { saveLeadToSupabase } from './modules/supabase-client.js';
import { calculateTotalCost, formatCost, formatTime } from './modules/cost-tracker.js';

dotenv.config();

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const anthropic = new Anthropic({
  apiKey: process.env.ANTHROPIC_API_KEY,
});

/**
 * AI Call Tracker - tracks usage and estimates costs
 */
class AICallTracker {
  constructor() {
    this.calls = [];
    this.totalInputTokens = 0;
    this.totalOutputTokens = 0;
  }

  trackCall(model, inputTokens, outputTokens, purpose) {
    this.calls.push({ model, inputTokens, outputTokens, purpose, timestamp: Date.now() });
    this.totalInputTokens += inputTokens || 0;
    this.totalOutputTokens += outputTokens || 0;
  }

  estimateCost(model, estimatedInputTokens = 1000, estimatedOutputTokens = 500) {
    const modelConfig = MODELS[model] || MODELS['gpt-5-mini'];
    const inputCost = (estimatedInputTokens / 1_000_000) * modelConfig.inputCost;
    const outputCost = (estimatedOutputTokens / 1_000_000) * modelConfig.outputCost;
    return inputCost + outputCost;
  }

  getTotalCost() {
    let total = 0;
    for (const call of this.calls) {
      const modelConfig = MODELS[call.model] || MODELS['gpt-5-mini'];
      const inputCost = (call.inputTokens / 1_000_000) * modelConfig.inputCost;
      const outputCost = (call.outputTokens / 1_000_000) * modelConfig.outputCost;
      total += inputCost + outputCost;
    }
    return total;
  }

  getSummary() {
    return {
      totalCalls: this.calls.length,
      totalInputTokens: this.totalInputTokens,
      totalOutputTokens: this.totalOutputTokens,
      estimatedCost: this.getTotalCost(),
      breakdown: this.calls
    };
  }
}

/**
 * Save analysis results to a structured folder
 * Creates: analysis-results/{domain}/{timestamp}/
 */
async function saveAnalysisResults(result) {
  try {
    // Extract domain from URL (e.g., "maksant.com")
    const domain = new URL(result.url).hostname.replace('www.', '');

    // Create timestamp folder (e.g., "2025-10-18_14-30-45")
    const timestamp = new Date().toISOString()
      .replace(/:/g, '-')
      .replace(/\..+/, '')
      .replace('T', '_');

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // FOLDER ORGANIZATION: Use LEAD GRADE (from QA Agent)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    const leadGrade = result.emailQA?.leadGrade || result.emailQA?.grade || 'C'; // Default to C if QA failed
    const folderPath = path.join(__dirname, 'analysis-results', `lead-${leadGrade}`, domain, timestamp);
    await fs.mkdir(folderPath, { recursive: true });

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // WEBSITE GRADE: Calculate based on ALL analysis modules
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    const grokData = result.grokData;

    // Check if we have contact info (EMAIL is most important!)
    const hasEmail = !!(grokData?.contactInfo?.email || result.contact?.email);
    const hasPhone = !!(grokData?.contactInfo?.phone || result.contact?.phone);
    const hasContact = hasEmail || hasPhone;

    let websiteScore = 0;
    let websiteGrade = 'F';

    // Base scoring: Data extraction (40 points max)
    if (hasEmail) websiteScore += 15;  // Email is CRITICAL
    if (hasPhone) websiteScore += 10;  // Phone is valuable
    if (grokData?.companyInfo?.name) websiteScore += 5;
    if (grokData?.companyInfo?.industry) websiteScore += 5;
    if (grokData?.companyInfo?.location) websiteScore += 5;

    // Analysis modules scoring (60 points max - based on what modules were run)
    const modulesUsed = result.modulesUsed || [];

    // Basic analysis always runs (15 points)
    if (modulesUsed.includes('basic')) {
      const basicCritiques = result.critiques?.basic || [];
      if (basicCritiques.length > 0) websiteScore += 15; // Found issues to analyze
    }

    // Industry analysis (15 points if enabled)
    if (modulesUsed.includes('industry')) {
      const industryCritiques = result.critiques?.industry || [];
      if (industryCritiques.length > 0) websiteScore += 15;
    }

    // SEO analysis (10 points if enabled)
    if (modulesUsed.includes('seo')) {
      if (result.seo) websiteScore += 10;
    }

    // Visual analysis (10 points if enabled)
    if (modulesUsed.includes('visual')) {
      const visualCritiques = result.critiques?.visual || [];
      if (visualCritiques.length > 0) websiteScore += 10;
    }

    // Competitor analysis (10 points if enabled)
    if (modulesUsed.includes('competitor')) {
      if (result.competitor) websiteScore += 10;
    }

    // Calculate website grade (based on comprehensiveness of analysis)
    if (!hasContact) {
      websiteGrade = 'F';  // No contact = F regardless of analysis
    } else if (websiteScore >= 70) {
      websiteGrade = 'A';  // Comprehensive analysis with contact info
    } else if (websiteScore >= 50) {
      websiteGrade = 'B';  // Good analysis with contact info
    } else if (websiteScore >= 30) {
      websiteGrade = 'C';  // Basic analysis or missing some modules
    } else if (websiteScore >= 10) {
      websiteGrade = 'D';  // Minimal analysis
    } else {
      websiteGrade = 'F';  // Almost no analysis
    }

    // Store both grades in result
    result.websiteScore = websiteScore;
    result.websiteGrade = websiteGrade;
    result.leadGrade = leadGrade; // From QA Agent

    // 1. Save full analysis data as JSON (now includes BOTH grades!)
    const analysisData = {
      url: result.url,
      companyName: result.companyName,
      industry: result.industry,
      timestamp: new Date().toISOString(),
      // TWO SEPARATE GRADES:
      websiteScore: websiteScore,      // How comprehensive the analysis was
      websiteGrade: websiteGrade,      // A-F based on modules run + data extracted
      leadGrade: leadGrade,            // A-F from QA Agent (email quality)
      contact: result.contact,
      extractedContact: result.extractedContact,
      grokData: result.grokData,
      critiques: result.critiques,
      seo: result.seo,
      visual: result.visual,
      competitor: result.competitor,
      summary: result.summary,
      loadTime: result.loadTime,
      pagesAnalyzed: result.pagesAnalyzed,
      modulesUsed: result.modulesUsed,
      emailQA: result.emailQA || null  // QA review data (NEW!)
    };

    await fs.writeFile(
      path.join(folderPath, 'analysis-data.json'),
      JSON.stringify(analysisData, null, 2),
      'utf8'
    );
    
    // 2. Save formatted critiques as readable text
    const critiquesText = formatCritiquesAsText(result);
    await fs.writeFile(
      path.join(folderPath, 'critiques.txt'),
      critiquesText,
      'utf8'
    );

    // 3. Save email content
    if (result.email) {
      const emailContent = `Subject: ${result.email.subject}\n\n${result.email.body}`;
      await fs.writeFile(
        path.join(folderPath, 'email.txt'),
        emailContent,
        'utf8'
      );

      // 3b. Save critique reasoning (explains WHY each critique was made)
      if (result.critiqueReasoning) {
        await fs.writeFile(
          path.join(folderPath, 'critique-reasoning.txt'),
          result.critiqueReasoning,
          'utf8'
        );
      }

      // 3c. Save QA review (lead quality assessment)
      if (result.emailQA) {
        const qaText = `LEAD QUALITY REVIEW (QA Agent)
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

LEAD GRADE: ${result.emailQA.leadGrade || result.emailQA.grade}
Ready to Contact: ${result.emailQA.passed ? 'YES' : 'NO'}

NOTE: Lead Grade is separate from Website Grade
- Website Grade (${websiteGrade}): How comprehensive the analysis was (modules run + data quality)
- Lead Grade (${result.emailQA.leadGrade || result.emailQA.grade}): How good the outreach email is (this grade)

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

Summary: ${result.emailQA.summary}

${result.emailQA.issues && result.emailQA.issues.length > 0 ? `
‚ùå CRITICAL ISSUES (Lead Grade F - DO NOT CONTACT):
${result.emailQA.issues.map((issue, i) => `   ${i + 1}. ${issue}`).join('\n')}
` : ''}
${result.emailQA.warnings && result.emailQA.warnings.length > 0 ? `
‚ö†Ô∏è  WARNINGS (Lead Grade B/C - review before contacting):
${result.emailQA.warnings.map((warning, i) => `   ${i + 1}. ${warning}`).join('\n')}
` : ''}
${result.emailQA.suggestions && result.emailQA.suggestions.length > 0 ? `
üí° SUGGESTIONS (Lead Grade A - nice-to-haves):
${result.emailQA.suggestions.map((suggestion, i) => `   ${i + 1}. ${suggestion}`).join('\n')}
` : ''}`;

        await fs.writeFile(
          path.join(folderPath, 'qa-review.txt'),
          qaText,
          'utf8'
        );
      }
    }

    // 4. Save client info summary (including blog posts for outreach hooks)
    const latestPost = grokData?.contentInfo?.recentPosts?.[0];
    const clientInfo = {
      companyName: result.companyName,
      url: result.url,
      industry: result.industry?.specific || grokData?.companyInfo?.industry || 'Unknown',
      location: grokData?.companyInfo?.location || 'Unknown',
      websiteScore: websiteScore,
      websiteGrade: websiteGrade,
      leadGrade: leadGrade,
      contact: {
        name: result.contact?.name || 'Unknown',
        email: result.contact?.email || grokData?.contactInfo?.email || 'Not found',
        phone: result.contact?.phone || grokData?.contactInfo?.phone || 'Not found',
        title: result.contact?.title || ''
      },
      recentBlogPost: latestPost ? {
        title: latestPost.title,
        date: latestPost.date,
        url: latestPost.url,
        summary: latestPost.summary
      } : null,
      hasActiveBlog: grokData?.contentInfo?.hasActiveBlog || false,
      socialProfiles: grokData?.socialProfiles || {},
      analyzedDate: new Date().toISOString(),
      emailSent: result.draft ? 'Draft created in Gmail' : 'Not sent'
    };
    
    await fs.writeFile(
      path.join(folderPath, 'client-info.json'),
      JSON.stringify(clientInfo, null, 2),
      'utf8'
    );

    // 5. Copy screenshot if it exists
    if (result.screenshot) {
      const screenshotName = path.basename(result.screenshot);
      const destPath = path.join(folderPath, screenshotName);
      try {
        await fs.copyFile(result.screenshot, destPath);
      } catch (err) {
        console.log('‚ö†Ô∏è Could not copy screenshot:', err.message);
      }
    }
    
    // 6. Save to Supabase leads table
    try {
      await saveLeadToSupabase({
        company_name: result.companyName || grokData?.companyInfo?.name || domain,
        website: result.url,
        industry: result.industry?.specific || grokData?.companyInfo?.industry || 'Unknown',
        location: grokData?.companyInfo?.location || 'Unknown',
        contact_name: result.contact?.name || grokData?.contactInfo?.name || null,
        contact_email: result.contact?.email || grokData?.contactInfo?.email || null,
        contact_phone: result.contact?.phone || grokData?.contactInfo?.phone || null,
        contact_title: result.contact?.title || null,
        grade: websiteGrade,
        website_score: websiteScore,
        analysis_data: JSON.stringify(clientInfo),
        screenshot_path: result.screenshot || null,
        analyzed_at: new Date().toISOString()
      });
      console.log(`‚úÖ Saved to Supabase leads table with grade ${websiteGrade}`);
    } catch (supabaseError) {
      console.error('‚ö†Ô∏è  Failed to save to Supabase:', supabaseError.message);
    }

    console.log(`\nüíæ Analysis saved to: ${folderPath}`);
    console.log(`   üìÅ Folder: lead-${leadGrade}/${domain}/${timestamp}`);
    console.log(`   üéØ Lead Grade: ${leadGrade} | Website Grade: ${websiteGrade}`);
    return folderPath;
    
  } catch (error) {
    console.error('‚ùå Error saving analysis results:', error);
    return null;
  }
}

/**
 * Format critiques as human-readable text
 */
function formatCritiquesAsText(result) {
  let text = `WEBSITE ANALYSIS RESULTS\n`;
  text += `${'='.repeat(80)}\n\n`;
  text += `Company: ${result.companyName}\n`;
  text += `URL: ${result.url}\n`;
  text += `Industry: ${result.industry?.specific || 'Unknown'}\n`;
  text += `Analysis Date: ${new Date().toLocaleString()}\n`;
  text += `Pages Analyzed: ${result.pagesAnalyzed}\n`;
  text += `Modules Used: ${result.modulesUsed.join(', ')}\n`;
  text += `\n${'='.repeat(80)}\n\n`;
  
  // General Issues
  if (result.critiques.basic && result.critiques.basic.length > 0) {
    text += `GENERAL ISSUES (${result.critiques.basic.length})\n`;
    text += `${'-'.repeat(80)}\n`;
    result.critiques.basic.forEach((critique, i) => {
      text += `${i + 1}. ${critique}\n\n`;
    });
  }
  
  // Industry-Specific Issues
  if (result.critiques.industry && result.critiques.industry.length > 0) {
    text += `INDUSTRY-SPECIFIC ISSUES (${result.critiques.industry.length})\n`;
    text += `${'-'.repeat(80)}\n`;
    result.critiques.industry.forEach((critique, i) => {
      text += `${i + 1}. ${critique}\n\n`;
    });
  }
  
  // SEO Issues
  if (result.critiques.seo && result.critiques.seo.length > 0) {
    text += `SEO ISSUES (${result.critiques.seo.length})\n`;
    text += `${'-'.repeat(80)}\n`;
    result.critiques.seo.forEach((critique, i) => {
      text += `${i + 1}. ${critique}\n\n`;
    });
  }
  
  // Visual Issues
  if (result.critiques.visual && result.critiques.visual.length > 0) {
    text += `VISUAL DESIGN ISSUES (${result.critiques.visual.length})\n`;
    text += `${'-'.repeat(80)}\n`;
    result.critiques.visual.forEach((critique, i) => {
      text += `${i + 1}. ${critique}\n\n`;
    });
  }
  
  // Competitor Analysis
  if (result.critiques.competitor && result.critiques.competitor.length > 0) {
    text += `COMPETITOR ANALYSIS (${result.critiques.competitor.length})\n`;
    text += `${'-'.repeat(80)}\n`;
    result.critiques.competitor.forEach((critique, i) => {
      text += `${i + 1}. ${critique}\n\n`;
    });
  }
  
  // Email
  if (result.email) {
    text += `${'='.repeat(80)}\n\n`;
    text += `OUTREACH EMAIL\n`;
    text += `${'-'.repeat(80)}\n`;
    text += `Subject: ${result.email.subject}\n\n`;
    text += `${result.email.body}\n`;
  }
  
  return text;
}

/**
 * Extract contact information from website content
 * Returns { firstName, fullName, email } or defaults
 */
function extractContactInfo(websiteData) {
  const bodyText = websiteData.bodyText || '';
  const title = websiteData.title || '';
  
  // Try to find "About" or "Team" section
  const aboutMatch = bodyText.match(/(?:About|Team|Meet|Founder|Owner|CEO|President)[:\s]+([A-Z][a-z]+(?:\s+[A-Z][a-z]+)?)/i);
  
  // Try to find email addresses (often near names)
  const emailMatch = bodyText.match(/([A-Z][a-z]+(?:\s+[A-Z][a-z]+)?)\s*[@\-\s]*([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})/);
  
  // Try to extract from title (often "FirstName LastName | Company")
  const titleMatch = title.match(/^([A-Z][a-z]+)(?:\s+[A-Z][a-z]+)?\s*[|\-]/);
  
  // Try common patterns like "Contact John Smith" or "Email: john.smith@..."
  const contactMatch = bodyText.match(/(?:Contact|Email|Call|Reach)\s+([A-Z][a-z]+(?:\s+[A-Z][a-z]+)?)/i);
  
  let fullName = null;
  let firstName = null;
  
  // Priority: aboutMatch > emailMatch > titleMatch > contactMatch
  if (aboutMatch) {
    fullName = aboutMatch[1].trim();
  } else if (emailMatch) {
    fullName = emailMatch[1].trim();
  } else if (titleMatch) {
    fullName = titleMatch[1].trim();
  } else if (contactMatch) {
    fullName = contactMatch[1].trim();
  }
  
  // Extract first name
  if (fullName) {
    firstName = fullName.split(/\s+/)[0];
  }
  
  // Extract email if found
  const emailPattern = /[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/;
  const email = bodyText.match(emailPattern)?.[0] || null;
  
  return {
    firstName: firstName || null,
    fullName: fullName || null,
    email: email || null
  };
}

/**
 * Optionally humanize a templated email with one AI call
 * Returns { subject, body } or the original email if humanization fails
 */
async function humanizeEmailWithAI(email, critique, options = {}) {
  // Skip humanization if explicitly disabled
  if (options.skipHumanize) {
    return email;
  }

  const model = options.textModel || process.env.DEFAULT_TEXT_MODEL || 'claude-sonnet-4-5-20250929';
  const tracker = options.aiTracker; // Get the tracker from options
  const context = options.personalizationContext || {}; // NEW: Get personalization context

  // Extract all critiques to give AI full context
  const allCritiques = [
    ...(critique.critiques || []),
    ...(critique.industryCritiques || []),
    ...(critique.seoCritiques || []),
    ...(critique.visualCritiques || []),
    ...(critique.competitorCritiques || [])
  ];

  // NEW: Extract personalization data from Grok
  const grokData = context.grokData || {};
  const latestPost = grokData?.contentInfo?.recentPosts?.[0];
  const services = grokData?.businessIntel?.services || [];
  const location = grokData?.companyInfo?.location;
  const industry = context.industry || grokData?.companyInfo?.industry;
  const socialProfiles = grokData?.socialProfiles || {};
  const recentNews = grokData?.businessIntel?.recentNews;
  const hasActiveBlog = grokData?.contentInfo?.hasActiveBlog;

  // Count social profiles
  const socialCount = [
    socialProfiles?.linkedIn?.company,
    socialProfiles?.instagram?.url,
    socialProfiles?.twitter?.url,
    socialProfiles?.facebook,
    socialProfiles?.youtube
  ].filter(Boolean).length;

  // Build personalization section
  let personalizationSection = '\nüéÅ PERSONALIZATION DATA (Use this to make the email feel personal!):\n\n';

  if (latestPost && latestPost.title) {
    const postDate = new Date(latestPost.date);
    const daysAgo = Math.floor((Date.now() - postDate.getTime()) / (1000 * 60 * 60 * 24));
    personalizationSection += `üìù RECENT BLOG POST (${daysAgo} days ago):\n`;
    personalizationSection += `   Title: "${latestPost.title}"\n`;
    personalizationSection += `   Date: ${latestPost.date}\n`;
    personalizationSection += `   Summary: ${latestPost.summary}\n`;
    if (daysAgo < 90) {
      personalizationSection += `   üí° OPPORTUNITY: Reference this in your opening! "Just read your ${latestPost.date.includes('2025') ? 'recent' : 'January'} post about [topic]..."\n`;
    }
    personalizationSection += '\n';
  }

  if (services.length > 0) {
    personalizationSection += `üõ†Ô∏è  SERVICES OFFERED: ${services.slice(0, 5).join(', ')}\n`;
    personalizationSection += `   üí° OPPORTUNITY: Mention specific service: "Noticed you offer ${services[0]}..."\n\n`;
  }

  if (location) {
    personalizationSection += `üìç LOCATION: ${location}\n`;
    if (industry) {
      personalizationSection += `   üí° OPPORTUNITY: Add local context: "For ${industry} businesses in ${location}..."\n`;
    }
    personalizationSection += '\n';
  }

  if (socialCount > 0) {
    const platforms = [];
    if (socialProfiles?.instagram?.url) platforms.push('Instagram');
    if (socialProfiles?.linkedIn?.company) platforms.push('LinkedIn');
    if (socialProfiles?.twitter?.url) platforms.push('Twitter');
    if (socialProfiles?.facebook) platforms.push('Facebook');
    if (socialProfiles?.youtube) platforms.push('YouTube');
    personalizationSection += `üì± SOCIAL MEDIA: ${platforms.join(', ')} (${socialCount} platform${socialCount > 1 ? 's' : ''})\n`;
    personalizationSection += `   üí° OPPORTUNITY: Compliment their presence: "Love your ${platforms[0]} content..."\n\n`;
  }

  if (recentNews) {
    personalizationSection += `üì∞ RECENT NEWS/ACHIEVEMENT:\n   ${recentNews}\n`;
    personalizationSection += `   üí° OPPORTUNITY: Congratulate them: "Congrats on [achievement]..."\n\n`;
  }

  if (context.pagesAnalyzed > 1) {
    personalizationSection += `üìÑ ANALYSIS DEPTH: Analyzed ${context.pagesAnalyzed} pages (not just homepage)\n`;
    personalizationSection += `   üí° OPPORTUNITY: Show thoroughness: "Looked at your Services and Contact pages too..."\n\n`;
  }

  if (!latestPost && !services.length && !location && !socialCount && !recentNews) {
    personalizationSection += `‚ö†Ô∏è  Limited personalization data available. Focus on compliment + critique.\n\n`;
  }

  // Add quality grade context
  const qualityGrade = context.qualityGrade || 'Unknown';
  const qualityScore = context.qualityScore || 0;

  personalizationSection += `üìä WEBSITE QUALITY GRADE: ${qualityGrade} (${qualityScore}/100)\n`;
  personalizationSection += `üí° IMPORTANT: Mention this grade to add credibility and show you used software analysis!\n\n`;

  if (qualityGrade === 'A') {
    personalizationSection += `   Grade A = "Your site scored an A in our analysis" (great foundation, small tweaks)\n`;
  } else if (qualityGrade === 'B') {
    personalizationSection += `   Grade B = "Your site scored a B" (good, but missing some key pieces)\n`;
  } else if (qualityGrade === 'C') {
    personalizationSection += `   Grade C = "Our analysis flagged a few findability issues" (be gentle)\n`;
  } else if (qualityGrade === 'D' || qualityGrade === 'F') {
    personalizationSection += `   Grade D/F = Don't mention specific grade. Say "noticed some gaps that might be costing you leads"\n`;
  }
  personalizationSection += '\n';

  // Build a simple humanize prompt
  const prompt = `You are a friendly business consultant writing a warm cold outreach email. Your goal: make someone feel good about their work, THEN gently show ONE thing that could make it even better.

CURRENT EMAIL:
Subject: ${email.subject}

Body:
${email.body}

ALL AVAILABLE CRITIQUES (you can reprioritize these):
${allCritiques.map((c, i) => `${i + 1}. ${c}`).join('\n')}

${personalizationSection}

üéØ GOLDEN RULE: Talk about BUSINESS OUTCOMES, not technical implementations.

ü•™ COMPLIMENT SANDWICH (MANDATORY):

**Opening (1-2 sentences):** USE PERSONALIZATION DATA ABOVE! Be specific:
‚úì "Just read your [recent blog post title] - loved the insights on..."
‚úì "Love your Instagram content (noticed you have X followers)..."
‚úì "For [industry] companies in [city], your [specific feature] is really smart"
‚úì "Noticed you offer [service 1], [service 2], and [service 3] - great range"
‚úó "I looked at your website" (not a compliment - TOO GENERIC!)
‚úó "Your site exists" (too generic)

**Middle (1 problem + 2-3 fixes):** Now give the constructive feedback

**Closing (1 sentence):** End positive and encouraging:
‚úì "You're already doing great work - these tweaks would just help more people find you"
‚úì "The foundation is solid, this would help you stand out even more"
‚úì "With these quick wins, you'd be converting way more leads"

üìã PERSONALIZATION RULES:
1. If recent blog post exists (<90 days): MUST reference it in opening
2. If services listed: Pick 1-2 specific ones to mention
3. If location known + industry known: Add local context
4. If social media active: Compliment their presence
5. If analyzed multiple pages: Mention it ("Checked out your Services page too...")
6. If recent news/achievement: Congratulate them

Instructions for SUBJECT LINE (CRITICAL - MUST PERSONALIZE!):
RESEARCH SHOWS: Personalized subject lines get 2x the click rates!
Best performing: 50-70 characters (sweet spot: 61-70 = 43.38% open rate)

MUST USE PERSONALIZATION DATA! Pick ONE of these approaches:
1. If blog post exists: "[Blog post topic]"
   Example: "Loved your post on client onboarding"
2. If company achievement/news: "Congrats on [achievement]"
3. If specific service: "Question about your [service]"
4. If location: "For [industry] in [city]"
5. If social media active: "Your [platform] content"

‚úó BANNED PHRASES - Never use these generic openers:
- "Quick question about..."
- "I looked at your website..."
- "Wanted to reach out..."
- "Hope this email finds you well..."

‚úì GOOD EXAMPLES (personalized):
- "Your Instagram content" (if they have active Instagram)
- "For HVAC companies in Vegas"
- "Question about your services page"
- "Loved your [specific feature]"

Keep it: Under 70 chars, conversational, specific to THEM

‚ö†Ô∏è  CRITICAL ANALYSIS BOUNDARIES - READ CAREFULLY! ‚ö†Ô∏è

YOU ${context.hasVisualAnalysis ? 'HAVE' : 'DO NOT HAVE'} VISUAL/SCREENSHOT ANALYSIS.
YOU ${context.pagesAnalyzed > 1 ? `ANALYZED ${context.pagesAnalyzed} PAGES` : 'ONLY ANALYZED 1 PAGE (homepage)'}.

${!context.hasVisualAnalysis ? `
üö´ WITHOUT VISUAL ANALYSIS, YOU CANNOT COMMENT ON:
- Button sizes ("make the button bigger")
- Layout positions ("move X above the fold")
- Colors ("your text is too light")
- Visual hierarchy ("your headline is buried")
- Image placement
- Spacing between elements
- What's "above the fold"

‚úÖ WITHOUT VISUAL ANALYSIS, YOU CAN ONLY COMMENT ON:
- Missing information in HTML (no phone number found, no email, etc.)
- Page load speed (from data provided)
- Content quality (from text scraped)
- Missing pages or broken structure
- SEO metadata issues
- General messaging/clarity from text content
` : ''}

${context.pagesAnalyzed === 1 ? `
üö´ YOU ONLY ANALYZED THE HOMEPAGE, SO DON'T:
- Reference other pages ("your services page shows...")
- Assume what's on other pages
- Talk about "throughout your site" (you only saw 1 page!)

‚úÖ YOU CAN:
- Comment on homepage findings
- Suggest they might have these issues elsewhere
- Recommend analyzing additional pages
` : ''}

Instructions for BODY:

1. TRANSLATE TECHNICAL JARGON TO PLAIN ENGLISH:
   ‚úó "Your H1 lacks a USP" ‚Üí ‚úì "Your headline doesn't explain what you do differently"
   ‚úó "Add structured data for SEO" ‚Üí ‚úì "Help Google show your site to the right people"
   ‚úó "Page load time is 5000ms" ‚Üí ‚úì "Your site takes 5 seconds to load (visitors expect 2-3)"
   ‚úó "Missing meta description" ‚Üí ‚úì "Google doesn't know how to describe your business"
   ‚úó "Low contrast ratio fails WCAG" ‚Üí ‚úì "Your text is hard to read (too light)"
   ‚úó "No canonical tag" ‚Üí ‚úì "Google might get confused about which page to show"
   ‚úó "Implement tel: links" ‚Üí ‚úì "Make your phone number tappable on mobile"
   ‚úó "Add schema markup" ‚Üí ‚úì "Help your reviews show up in search results"

2. LEAD WITH BUSINESS IMPACT (not technical problems):
   ‚úó "Your title tag is too long"
   ‚úì "Visitors can't tell what you do in the first 3 seconds"
   
   ‚úó "You're missing a sitemap.xml"
   ‚úì "Google can't find all your pages"
   
   ‚úó "No CTAs above the fold"
   ‚úì "Most visitors don't know what to do next"

3. SIMPLIFY THE STRUCTURE (2-5 sentences, max 200 words):
   - OPEN WITH A COMPLIMENT (mandatory - find something genuinely good)
   - Then state ONE clear problem (business language, not tech)
   - Give 2-3 simple fixes (conversational bullets, NO sub-bullets)
   - CLOSE WITH ENCOURAGEMENT (mandatory - reinforce their strengths)
   - Each fix should be ONE line, easy to understand
   - NO acronyms: H1, USP, CTA, KPI, SEO, UX, CTR, WCAG, etc.
   - NO technical terms: structured data, canonical tag, robots.txt, meta tags, etc.

   ‚ö†Ô∏è  VARY YOUR CRITIQUES! Don't always focus on the same issues:
   - Don't always talk about mobile/responsive issues
   - Don't always focus on contact forms
   - Mix up: messaging, content, trust signals, clarity, findability, etc.
   - Look at what SPECIFIC problems THIS site has

4. MENTION THE SOFTWARE ANALYSIS (Build credibility!):
   - Research shows 63% of users trust AI analysis when you're transparent about it
   - Weave it naturally into the email - don't make it salesy

   GOOD WAYS TO MENTION IT:
   ‚úì "Ran your site through our analysis tool ‚Äî scored an A overall"
   ‚úì "I use software to analyze sites (helps me spot things quickly)"
   ‚úì "Our tool flagged a few quick wins that could help"
   ‚úì "After analyzing your site (software + manual review)..."

   DON'T:
   ‚úó "BUY MY SOFTWARE!"
   ‚úó Make it the main focus
   ‚úó Be vague about what you found

   POSITIONING BY GRADE:
   - Grade A: "Your site scored an A ‚Äî really solid foundation"
   - Grade B: "Your site scored a B in our analysis ‚Äî just a few gaps"
   - Grade C/D/F: Don't mention grade. Say "ran it through our tool" or "noticed a few gaps"

5. TONE & STYLE:
   - WARM and ENTHUSIASTIC (not just clinical)
   - Show genuine appreciation for what they're doing well
   - Conversational and helpful (like a friend who wants to see them succeed)
   - Frame issues as opportunities, not failures
   - Keep it SHORT (10-12 lines MAX, including greeting, compliment, fixes, encouragement, and CTA)
   - End with an easy, low-pressure next step

6. WHAT TO AVOID:
   ‚úó Multiple section headers (GENERAL ISSUES, SEO ISSUES, etc.)
   ‚úó Long bullet points with sub-items
   ‚úó Parenthetical tech details: "(live link, 2-3 screenshots, tech stack, role, KPI)"
   ‚úó Corporate jargon: "leverage", "optimize", "synergize", "utilize"
   ‚úó Overwhelming detail: "Publish 3-5 long-form case studies..."
   ‚úó SKIPPING THE COMPLIMENT (must start positive!)
   ‚úó SKIPPING THE ENCOURAGEMENT (must end positive!)

EXAMPLE PERSONALIZED EMAIL (USING BLOG POST + SERVICES + LOCATION):

Subject: Loved your post on client onboarding

Hi Maksant team,

Just read your January post about reducing client onboarding by 40% - that's exactly the kind of efficiency thinking that separates great agencies from good ones. Noticed you offer One-Page Starter, Business Website, and Online Store packages - smart range for Philly businesses.

Quick observation: your FEATURED WORK section lists Arsenal, LQRS, and Modenza, but doesn't show outcome metrics. For web design agencies in Swarthmore, adding "Client got 40% more leads" or "Delivered in 12 days" would make those way more compelling.

You're clearly delivering results - this tweak just helps prospects see them faster.

Want a 15-min call? I can walk you through exactly where to add these.

Best,
Anton Yanovich
Co-Founder, Maksant
https://maksant.com
412-315-8398

---

EXAMPLE BASIC EMAIL (NO BLOG POST, USING SERVICES + LOCATION):

Subject: For HVAC in Vegas

Hi [Company],

Noticed you offer AC installation, repair, and maintenance - smart range for Vegas homeowners. Your 24/7 emergency service is a major value prop that not every HVAC company highlights.

One gap I noticed: your homepage doesn't show pricing ranges or service costs, so prospects can't self-qualify. Right now visitors have to call to find out if you're in their budget.

You're already building trust with 24/7 availability - adding "Starting at $X for tune-ups" would help more locals pick you.

Quick call?

Best,
Anton Yanovich
Co-Founder, Maksant
https://maksant.com
412-315-8398

---

NOW REWRITE THE EMAIL ABOVE USING THE COMPLIMENT SANDWICH FORMAT + PERSONALIZATION DATA.

CRITICAL PERSONALIZATION REQUIREMENTS - HONEST ONLY:
1. ‚úÖ CHECK PERSONALIZATION DATA section above
2. ‚úÖ If blog post exists: Reference specific title/topic in opening (HIGH PRIORITY!)
3. ‚úÖ If services exist: Mention 1-2 specific ones by name
4. ‚úÖ If location + industry known: Add local context ("For [industry] in [city]...")
5. ‚úÖ If social media URL exists: Say "I see you're on Instagram" or "Noticed you're active on Facebook" (NO fake engagement like "Love your content!")
6. ‚úÖ If analyzed multiple pages: Show thoroughness ("Reviewed your homepage + About page + Services")
7. ‚úÖ DO NOT use generic openings like "I checked out your website" if personalization data is available

üö® BANNED FAKE PERSONALIZATION:
‚ùå "Love your Instagram content" (we didn't see Instagram content!)
‚ùå "Your Facebook posts are great" (we didn't read Facebook posts!)
‚ùå "Love your tweets" (we didn't read tweets!)
‚ùå "Your Instagram photos are amazing" (we didn't see photos!)
‚ùå ANY comment on social media CONTENT when we only have the URL

‚úÖ HONEST ALTERNATIVES:
‚úì "I see you're active on Instagram" (if Instagram URL found)
‚úì "Noticed you're on Facebook" (if Facebook URL found)
‚úì "Your services include X, Y, Z" (if services extracted)
‚úì "Read your blog post about [topic]" (ONLY if blog post title/content extracted)

OTHER REQUIREMENTS:
- MUST start with a personalized compliment (use data above!)
- MUST end with encouragement (reinforce their strengths)
- Keep it warm, conversational, and enthusiastic
- Translate ALL technical jargon to plain English
- Focus on business outcomes, not technical fixes
- Length: 10-12 lines MAX

OPTIONAL: Add credibility by briefly mentioning who you are (e.g., "I help businesses like yours get more leads from their websites" or "I specialize in helping [industry] companies convert more visitors"). Only include this if it feels natural ‚Äî don't force it.

SIGNATURE FORMAT (REQUIRED):
End every email with this EXACT format:

Best,
Anton Yanovich
Co-Founder, Maksant
https://maksant.com
412-315-8398

Return format:
[subject line - short, conversational, no jargon]

[body - plain English, business-focused, 10-12 lines max, MUST include compliment + fixes + encouragement + signature]`;

  try {
    const result = await callAI({ model, prompt, systemPrompt: 'You are a concise email writer who uses proper formatting.' });
    
    // Track the AI call
    if (tracker && result.usage) {
      tracker.trackCall(model, result.usage.inputTokens, result.usage.outputTokens, 'email_humanization');
    }
    
    if (!result || !result.text) return email;

    const lines = result.text.split(/\r?\n/);
    const firstNonEmpty = lines.findIndex(l => l.trim().length > 0);
    
    if (firstNonEmpty < 0) return email;

    const subjectLine = lines[firstNonEmpty].trim();
    
    // Find the next non-empty line after a blank line (or after subject)
    let bodyStart = firstNonEmpty + 1;
    while (bodyStart < lines.length && lines[bodyStart].trim() === '') {
      bodyStart++;
    }
    
    const bodyText = lines.slice(bodyStart).join('\n').trim();

    if (!subjectLine || !bodyText) return email;

    return { subject: subjectLine, body: bodyText };

  } catch (error) {
    console.error('Email humanization failed:', error.message);
    return email;
  }
}

/**
 * Generate critique reasoning for the user to understand WHY each critique was made
 * This helps the user review and customize the email with full context
 * Uses a cheap model (GPT-4o-mini or Haiku) to save costs
 */
async function generateCritiqueReasoning(email, critique, personalizationContext, options = {}) {
  // Use cheap model for reasoning (GPT-4o-mini or Claude Haiku)
  const model = process.env.CHEAP_MODEL || 'gpt-4o-mini';
  const tracker = options.aiTracker;

  // Build prompt asking AI to explain its reasoning
  const prompt = `You just wrote this outreach email:

SUBJECT: ${email.subject}

BODY:
${email.body}

---

Now, explain your reasoning for each critique/suggestion you made in the email. For the user reviewing this email, help them understand:

1. **What data led you to this critique?** (What did you see in the analysis?)
2. **Why is this important?** (Business impact)
3. **What alternatives did you consider?** (Other ways to phrase it or other issues you could have focused on)

Format your response as a bullet list, one bullet per major critique/suggestion in the email. Keep it concise but informative.

PERSONALIZATION DATA YOU HAD ACCESS TO:
${JSON.stringify(personalizationContext, null, 2)}

ANALYSIS DATA:
${JSON.stringify(critique, null, 2)}`;

  try {
    const result = await callAI({
      model,
      prompt,
      systemPrompt: 'You are a helpful assistant explaining email critique reasoning to help users review and customize outreach emails.'
    });

    // Track the AI call
    if (tracker && result.usage) {
      tracker.trackCall(model, result.usage.inputTokens, result.usage.outputTokens, 'critique_reasoning');
    }

    return result?.text || 'Reasoning generation failed';

  } catch (error) {
    console.error('Critique reasoning generation failed:', error.message);
    return `Error generating reasoning: ${error.message}`;
  }
}

/**
 * QA Review Agent - Determines LEAD QUALITY (separate from website quality)
 *
 * TWO TYPES OF GRADES:
 * - Website Quality (A-F): How much data we extracted (email, phone, services, etc.)
 * - Lead Quality (A-F): How good the outreach email is ‚Üê THIS AGENT DECIDES
 *
 * This agent has the FINAL SAY on whether a lead is worth contacting.
 * Even if website has all data (Website Grade A), if email is generic/fake/bad ‚Üí Lead Grade F
 *
 * Uses a cheap model (GPT-4o-mini or Haiku) to save costs
 *
 * @param {Object} email - The generated email {subject, body}
 * @param {Object} context - Context about the analysis {modulesUsed, hasVisualAnalysis, grokData, companyName}
 * @param {Object} options - Options {aiTracker}
 * @returns {Object} - QA result {leadGrade, passed, issues[], warnings[], suggestions[]}
 */
async function qaReviewEmail(email, context, options = {}) {
  const model = process.env.CHEAP_MODEL || 'gpt-4o-mini';
  const tracker = options.aiTracker;

  // Build context for QA agent
  const qaContext = {
    modulesUsed: context.modulesUsed || [],
    hasVisualAnalysis: context.hasVisualAnalysis || false,
    hasEmail: !!context.contact?.email,
    hasPhone: !!context.grokData?.contactInfo?.phone,
    companyName: context.companyName || 'Unknown',
    hasBlogPosts: (context.grokData?.contentInfo?.recentPosts?.length || 0) > 0,
    hasSocialProfiles: !!(context.grokData?.socialProfiles?.instagram?.url ||
                          context.grokData?.socialProfiles?.facebook ||
                          context.grokData?.socialProfiles?.linkedIn?.company)
  };

  const prompt = `You are the LEAD QUALITY AGENT. You determine whether this lead is worth contacting.

IMPORTANT: You grade LEAD QUALITY (email readiness), NOT website quality (data completeness).

EMAIL TO REVIEW:
Subject: ${email.subject}

Body:
${email.body}

---

ANALYSIS CONTEXT (what modules were run):
${JSON.stringify(qaContext, null, 2)}

---

QA CHECKLIST - Check for these issues:

1. **CRITICAL ISSUES** (Lead Grade F - DO NOT CONTACT):
   ‚ùå Missing recipient email (hasEmail: false) - can't send if no email!
   ‚ùå Missing subject line or body
   ‚ùå Generic template language ("Quick question about your site", "I checked out your website")
   ‚ùå Visual critiques when visual module was OFF (check modulesUsed array - if "visual" not in list, NO button/color/layout comments allowed)
   ‚ùå Fake personalization (says "Love your Instagram posts" when hasBlogPosts: false - we only have URLs, not content)

2. **WARNINGS** (Lead Grade B/C - review before contacting):
   ‚ö†Ô∏è Very generic subject (not personalized)
   ‚ö†Ô∏è No specific company/service references
   ‚ö†Ô∏è Too long (over 15 lines)
   ‚ö†Ô∏è Missing signature
   ‚ö†Ô∏è Unclear call-to-action

3. **SUGGESTIONS** (Lead Grade A - nice-to-haves):
   üí° Could mention specific services if not mentioned
   üí° Could reference company name if not mentioned
   üí° Could be more specific about the critique

LEAD QUALITY GRADING (THIS IS YOUR PRIMARY JOB):
- Lead Grade A: No critical issues, max 1 warning ‚Üí CONTACT IMMEDIATELY
- Lead Grade B: No critical issues, 2-3 warnings ‚Üí REVIEW THEN CONTACT
- Lead Grade C: No critical issues but 4+ warnings ‚Üí NEEDS EDITING
- Lead Grade D: Almost all warnings, barely passable ‚Üí MAJOR REWRITE NEEDED
- Lead Grade F: Has critical issues ‚Üí DO NOT CONTACT

Return ONLY valid JSON:
{
  "passed": true/false,
  "leadGrade": "A/B/C/D/F",
  "issues": ["Critical issue 1", "Critical issue 2"],
  "warnings": ["Warning 1", "Warning 2"],
  "suggestions": ["Suggestion 1", "Suggestion 2"],
  "summary": "One sentence assessment of LEAD quality (not website quality)"
}`;

  try {
    const result = await callAI({
      model,
      prompt,
      systemPrompt: 'You are a QA reviewer for outreach emails. Always return valid JSON.'
    });

    // Track the AI call
    if (tracker && result.usage) {
      tracker.trackCall(model, result.usage.inputTokens, result.usage.outputTokens, 'qa_review');
    }

    // Parse JSON response (strip markdown code fences if present)
    let jsonText = result.text.trim();

    // Remove markdown code fences if present (```json ... ```)
    if (jsonText.startsWith('```')) {
      jsonText = jsonText.replace(/^```(?:json)?\s*\n/, '').replace(/\n```\s*$/, '');
    }

    const qaResult = JSON.parse(jsonText);
    return qaResult;

  } catch (error) {
    console.error('QA review failed:', error.message);
    // Return a safe default that allows email to be saved
    return {
      passed: true,
      leadGrade: 'B',
      issues: [],
      warnings: [`QA review failed: ${error.message}`],
      suggestions: [],
      summary: 'QA review encountered an error - defaulting to Lead Grade B'
    };
  }
}

/**
 * Analyze a single website with progress updates
 */
async function analyzeWebsite(url, browser, sendProgress) {
  console.log(`Analyzing: ${url}`);

  sendProgress({
    type: 'step',
    step: 'loading_page',
    message: `‚è≥ Loading homepage...`,
    url
  });

  const context = await browser.newContext({
    viewport: { width: 1920, height: 1080 },
    userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
  });

  const page = await context.newPage();

  try {
    // Navigate to the page
    const startTime = Date.now();
    await page.goto(url, {
      waitUntil: 'networkidle',
      timeout: 30000
    });
    const loadTime = Date.now() - startTime;

    sendProgress({
      type: 'step',
      step: 'page_loaded',
      message: `‚úì Homepage loaded (${(loadTime / 1000).toFixed(1)}s)`,
      url
    });

    sendProgress({
      type: 'step',
      step: 'capturing_screenshot',
      message: `‚è≥ Capturing screenshots...`,
      url
    });

    // Capture screenshot
    const screenshotDir = './screenshots';
    await fs.mkdir(screenshotDir, { recursive: true });

    const domain = new URL(url).hostname.replace(/[^a-z0-9]/gi, '_');
    const timestamp = Date.now();
    const screenshotPath = path.join(screenshotDir, `${domain}_${timestamp}.png`);

    await page.screenshot({
      path: screenshotPath,
      fullPage: false
    });

    // Gather website data
    const websiteData = await page.evaluate(() => {
      const bodyText = document.body.innerText;
      const data = {
        title: document.title,
        metaDescription: document.querySelector('meta[name="description"]')?.content || '',
        h1Tags: Array.from(document.querySelectorAll('h1')).map(h => h.innerText).slice(0, 5),
        hasContactForm: !!document.querySelector('form'),
        hasCTA: !!(
          document.querySelector('button') ||
          document.querySelector('a[href*="contact"]') ||
          document.querySelector('a[href*="get-started"]') ||
          document.querySelector('a[href*="book"]')
        ),
        imageCount: document.querySelectorAll('img').length,
        linkCount: document.querySelectorAll('a').length,
        hasChat: !!(
          document.querySelector('[class*="chat"]') ||
          document.querySelector('[id*="chat"]')
        ),
        hasPhoneNumber: /\(?\d{3}\)?[-.\s]?\d{3}[-.\s]?\d{4}/.test(bodyText),
        hasPortfolio: !!(
          document.querySelector('[class*="portfolio"]') ||
          document.querySelector('[class*="work"]') ||
          document.querySelector('[class*="project"]') ||
          bodyText.toLowerCase().includes('featured work') ||
          bodyText.toLowerCase().includes('our work') ||
          bodyText.toLowerCase().includes('case stud')
        ),
        // Check if portfolio items are CLICKABLE (likely link to detailed case studies)
        portfolioItemCount: (() => {
          const selectors = [
            '[class*="portfolio"] a[href]',
            '[class*="work"] a[href]',
            '[class*="project"] a[href]',
            '[class*="case-study"] a[href]',
            'a[href*="/portfolio/"]',
            'a[href*="/work/"]',
            'a[href*="/projects/"]',
            'a[href*="/case-studies/"]'
          ];
          let count = 0;
          for (const selector of selectors) {
            const items = document.querySelectorAll(selector);
            count = Math.max(count, items.length);
          }
          return count;
        })(),
        hasTestimonials: !!(
          document.querySelector('[class*="testimonial"]') ||
          document.querySelector('[class*="review"]') ||
          bodyText.toLowerCase().includes('what our clients say') ||
          bodyText.toLowerCase().includes('client testimonial')
        ),
        viewport: {
          width: window.innerWidth,
          height: window.innerHeight
        },
        bodyText: bodyText.slice(0, 5000), // First 5000 chars (captures more content like portfolio, footer)
      };
      return data;
    });

    // FULL MOBILE SCRAPE - Switch to mobile viewport and re-scrape everything
    await page.setViewportSize({ width: 375, height: 667 }); // iPhone size
    await page.waitForTimeout(1000); // Give time for mobile layout to render

    const mobileScreenshotPath = path.join(screenshotDir, `${domain}_${timestamp}_mobile.png`);
    await page.screenshot({
      path: mobileScreenshotPath,
      fullPage: false
    });

    // FULL mobile data scrape (same as desktop, but at mobile viewport)
    const mobileData = await page.evaluate(() => {
      const bodyText = document.body.innerText;
      const data = {
        title: document.title,
        metaDescription: document.querySelector('meta[name="description"]')?.content || '',
        h1Tags: Array.from(document.querySelectorAll('h1')).map(h => h.innerText).slice(0, 5),
        hasContactForm: !!document.querySelector('form'),
        hasCTA: !!(
          document.querySelector('button') ||
          document.querySelector('a[href*="contact"]') ||
          document.querySelector('a[href*="get-started"]') ||
          document.querySelector('a[href*="book"]')
        ),
        imageCount: document.querySelectorAll('img').length,
        linkCount: document.querySelectorAll('a').length,
        hasChat: !!(
          document.querySelector('[class*="chat"]') ||
          document.querySelector('[id*="chat"]')
        ),
        hasPhoneNumber: /\(?\d{3}\)?[-.\s]?\d{3}[-.\s]?\d{4}/.test(bodyText),
        hasClickToCallLinks: document.querySelectorAll('a[href^="tel:"]').length > 0,
        phoneNumbers: Array.from(new Set(
          bodyText.match(/\(?\d{3}\)?[-.\s]?\d{3}[-.\s]?\d{4}/g) || []
        )),
        hasPortfolio: !!(
          document.querySelector('[class*="portfolio"]') ||
          document.querySelector('[class*="work"]') ||
          document.querySelector('[class*="project"]') ||
          bodyText.toLowerCase().includes('featured work') ||
          bodyText.toLowerCase().includes('our work') ||
          bodyText.toLowerCase().includes('case stud')
        ),
        portfolioItemCount: (() => {
          const selectors = [
            '[class*="portfolio"] a[href]',
            '[class*="work"] a[href]',
            '[class*="project"] a[href]',
            '[class*="case-study"] a[href]',
            'a[href*="/portfolio/"]',
            'a[href*="/work/"]',
            'a[href*="/projects/"]',
            'a[href*="/case-studies/"]'
          ];
          let count = 0;
          for (const selector of selectors) {
            const items = document.querySelectorAll(selector);
            count = Math.max(count, items.length);
          }
          return count;
        })(),
        hasTestimonials: !!(
          document.querySelector('[class*="testimonial"]') ||
          document.querySelector('[class*="review"]') ||
          bodyText.toLowerCase().includes('what our clients say') ||
          bodyText.toLowerCase().includes('client testimonial')
        ),
        hasMobileMenu: !!(
          document.querySelector('[class*="mobile-menu"]') ||
          document.querySelector('[class*="hamburger"]') ||
          document.querySelector('[id*="mobile-menu"]') ||
          document.querySelector('[class*="nav-toggle"]') ||
          document.querySelector('button[aria-label*="menu" i]')
        ),
        primaryCTASize: (() => {
          const ctas = document.querySelectorAll('a[href*="contact"], button, .cta, [class*="btn"]');
          if (ctas.length === 0) return null;
          const firstCTA = ctas[0];
          const rect = firstCTA.getBoundingClientRect();
          const isVisible = rect.width > 0 && rect.height > 0;
          return isVisible ? { 
            width: Math.round(rect.width), 
            height: Math.round(rect.height),
            isTappable: rect.height >= 44 && rect.width >= 44
          } : null;
        })(),
        visibleContentAboveFold: (() => {
          const viewportHeight = window.innerHeight;
          const elementsAboveFold = Array.from(document.querySelectorAll('h1, h2, p, button, a'))
            .filter(el => {
              const rect = el.getBoundingClientRect();
              return rect.top >= 0 && rect.top <= viewportHeight && rect.height > 0;
            });
          return {
            headlineCount: elementsAboveFold.filter(el => el.tagName === 'H1' || el.tagName === 'H2').length,
            ctaCount: elementsAboveFold.filter(el => el.tagName === 'BUTTON' || el.tagName === 'A').length,
            textLength: elementsAboveFold.map(el => el.innerText).join(' ').length
          };
        })(),
        viewport: {
          width: window.innerWidth,
          height: window.innerHeight
        },
        bodyText: bodyText.slice(0, 5000)
      };
      return data;
    });

    // Store mobile data separately
    websiteData.mobile = mobileData;

    sendProgress({
      type: 'step',
      step: 'screenshots_captured',
      message: `‚úì Full scrape complete (desktop + mobile data)`,
      url
    });

    // GROK EXTRACTION: Extract comprehensive data using AI
    sendProgress({
      type: 'step',
      step: 'grok_extraction',
      message: `ü§ñ Extracting company data with AI...`,
      url
    });

    let grokData = null;
    let contactInfo = null;

    try {
      const html = await page.content();
      grokData = await extractWithGrok(html, url, 'grok-4-fast', page);

      // Convert Grok data to legacy contactInfo format for compatibility
      contactInfo = {
        pageUrl: url,
        emails: grokData.contactInfo?.email ? [{ value: grokData.contactInfo.email, source: 'grok' }] : [],
        phones: grokData.contactInfo?.phone ? [{ value: grokData.contactInfo.phone, source: 'grok' }] : [],
        names: grokData.teamInfo?.founder?.name ? [grokData.teamInfo.founder.name] : [],
        contactPages: [],

        // NEW: Enhanced data from Grok
        companyName: grokData.companyInfo?.name,
        industry: grokData.companyInfo?.industry,
        location: grokData.companyInfo?.location,
        foundingYear: grokData.companyInfo?.foundingYear,
        services: grokData.businessIntel?.services,
        valueProposition: grokData.businessIntel?.valueProposition,
        socialProfiles: grokData.socialProfiles,
        recentContent: grokData.contentInfo?.recentPosts,
        hasActiveBlog: grokData.contentInfo?.hasActiveBlog
      };

      sendProgress({
        type: 'info',
        message: `‚úÖ AI extraction complete (${grokData._meta.tokensUsed.input} tokens)`,
        url
      });
    } catch (e) {
      console.error('Grok extraction failed:', e.message);

      // Fallback to traditional extraction
      sendProgress({
        type: 'warning',
        message: `‚ö†Ô∏è AI extraction failed, using traditional scraper...`,
        url
      });

      try {
        contactInfo = await extractFromPage(page, url);
      } catch (fallbackError) {
        contactInfo = { pageUrl: url, emails: [], phones: [], names: [], contactPages: [] };
      }
    }

    await context.close();

    return {
      url,
      loadTime,
      screenshotPath,
      mobileScreenshotPath,
      data: websiteData,
      contact: contactInfo,
      grokData: grokData,  // NEW: Full Grok extraction data
      error: null
    };

  } catch (error) {
    await context.close();
    console.error(`Error analyzing ${url}:`, error.message);

    return {
      url,
      error: error.message,
      data: null
    };
  }
}

/**
 * Generate AI critique using Claude with progress updates
 */
async function generateCritique(websiteAnalysis, industry, seoResults, visualResults, competitorResults, sendProgress, options = {}) {
  if (websiteAnalysis.error) {
    return {
      critiques: [`Unable to analyze website: ${websiteAnalysis.error}`],
      industryCritiques: [],
      seoCritiques: [],
      visualCritiques: [],
      competitorCritiques: [],
      companyName: new URL(websiteAnalysis.url).hostname,
      summary: 'Analysis failed',
      industry: null,
      seo: null,
      visual: null,
      competitor: null
    };
  }

  const { url, loadTime, data } = websiteAnalysis;
  const tracker = options.aiTracker;
  const textModel = options.textModel || 'claude-sonnet-4-5';

  sendProgress({
    type: 'step',
    step: 'ai_analysis',
    message: `‚è≥ Running AI analysis with dynamic prompt builder...`,
    url
  });

  // Build dynamic, context-aware prompt using the new prompt builder
  // Pass visualResults so the prompt knows if visual analysis is available
  const basePrompt = buildAnalysisPrompt(data, industry, seoResults, url, loadTime, visualResults);
  const contentSection = buildContentSection(data);

  const prompt = `${basePrompt}

${contentSection}`;



  try {
    const aiResult = await callAI({
      model: textModel,
      prompt: prompt,
      systemPrompt: 'You are a website critique assistant. Return only valid JSON.'
    });

    console.log('AI result received:', aiResult ? 'Yes' : 'No', 'Has text:', aiResult?.text ? 'Yes' : 'No');

    // Track the AI call
    if (tracker && aiResult && aiResult.usage) {
      tracker.trackCall(textModel, aiResult.usage.inputTokens, aiResult.usage.outputTokens, 'website_critique');
    }

    // Check if we got a valid response
    if (!aiResult || !aiResult.text) {
      console.error('AI returned empty or invalid response. aiResult:', JSON.stringify(aiResult, null, 2));
      throw new Error('AI returned empty response');
    }

    let responseText = aiResult.text;

    // Validate JSON response using json-validator
    const validation = validateJSON(responseText, 'websiteAnalysis');

    // Log validation result if debug mode
    if (process.env.DEBUG_AI === 'true') {
      console.log('\n' + formatValidationResult(validation));
    }

    let result;

    if (validation.isValid) {
      // Validation passed - use validated data
      result = validation.data;
      sendProgress({
        type: 'info',
        message: '‚úÖ AI response validated successfully',
        url
      });

      // LAYER 2: AI Quality Check (optional, cheap)
      if (process.env.ENABLE_AI_QUALITY_CHECK === 'true') {
        sendProgress({
          type: 'step',
          step: 'quality_check',
          message: 'üîç Running AI quality check...',
          url
        });

        const qualityCheck = await validateQualityWithAI(result, 'websiteAnalysis', {
          model: process.env.QUALITY_CHECK_MODEL || 'gpt-4o-mini',
          forceCheck: false // Only check if suspicious signals detected
        });

        if (qualityCheck.skipped) {
          sendProgress({
            type: 'info',
            message: '‚úÖ Quality check skipped (no issues detected)',
            url
          });
        } else if (!qualityCheck.isQualityGood && qualityCheck.fixedVersion) {
          // Use AI-corrected version
          console.log('üîß Using AI-corrected version');
          console.log('Issues found:', qualityCheck.issues.join(', '));
          result = qualityCheck.fixedVersion;
          sendProgress({
            type: 'warning',
            message: `‚ö†Ô∏è AI fixed ${qualityCheck.issues.length} quality issues ($${qualityCheck.cost.toFixed(4)})`,
            url
          });
        } else if (!qualityCheck.isQualityGood) {
          // Quality issues but no fix available
          console.warn('‚ö†Ô∏è Quality issues detected (no auto-fix):', qualityCheck.issues.join(', '));
          sendProgress({
            type: 'warning',
            message: `‚ö†Ô∏è ${qualityCheck.issues.length} quality issues detected ($${qualityCheck.cost.toFixed(4)})`,
            url
          });
        } else {
          sendProgress({
            type: 'info',
            message: `‚úÖ Quality check passed ($${qualityCheck.cost.toFixed(4)})`,
            url
          });
        }
      }
    } else {
      // Validation failed - try fallback parsing
      console.warn('‚ö†Ô∏è AI response failed validation, attempting fallback parsing...');
      console.warn('Validation errors:', validation.errors.join(', '));

      // Try legacy parsing
      responseText = responseText.replace(/```(?:json)?\s*([\s\S]*?)```/gi, '$1').trim();
      result = parseJSONFromText(responseText);

      // If parsing completely failed, try heuristic extraction
      if (!result) {
        const { extractPartialResult } = await import('./modules/ai-utils.js');
        result = extractPartialResult(responseText);
      }

      // If we still have nothing, log the response and throw
      if (!result) {
        console.error('Failed to parse AI response. Raw text:', responseText.substring(0, 500));
        throw new Error('Failed to parse AI JSON response after validation and fallback attempts');
      }

      sendProgress({
        type: 'warning',
        message: '‚ö†Ô∏è Used fallback parsing (AI response format was unexpected)',
        url
      });
    }

    // Ensure critiques is always an array (defensive)
    if (!result.critiques || !Array.isArray(result.critiques)) {
      if (typeof result.critiques === 'string') {
        // Split string into array
        result.critiques = result.critiques.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
      } else {
        result.critiques = [];
      }
    }

    // Extract critique categories based on what modules were enabled
    const finalResult = {
      companyName: result.companyName || new URL(url).hostname,
      critiques: result.critiques.slice(0, 3),
      industryCritiques: industry ? result.critiques.slice(3, 5) : [],
      seoCritiques: seoResults ? (industry ? result.critiques.slice(5, 7) : result.critiques.slice(3, 5)) : [],
      visualCritiques: visualResults ? visualResults.critiques : [],
      competitorCritiques: competitorResults ? competitorResults.critiques : [],
      summary: result.summary || 'Website analysis complete',
      industry: industry,
      seo: seoResults,
      visual: visualResults,
      competitor: competitorResults
    };

    const critiqueCountMsg = `‚úì Generated ${finalResult.critiques.length} general${finalResult.industryCritiques.length > 0 ? ` + ${finalResult.industryCritiques.length} industry` : ''}${finalResult.seoCritiques.length > 0 ? ` + ${finalResult.seoCritiques.length} SEO` : ''}${finalResult.visualCritiques.length > 0 ? ` + ${finalResult.visualCritiques.length} visual` : ''}${finalResult.competitorCritiques.length > 0 ? ` + ${finalResult.competitorCritiques.length} competitor` : ''} critiques`;

    sendProgress({
      type: 'step',
      step: 'ai_complete',
      message: critiqueCountMsg,
      url
    });

    return finalResult;

  } catch (error) {
    console.error('AI critique generation error:', error);

    const fallbackCritiques = [
      `Page load time of ${(loadTime / 1000).toFixed(1)} seconds may be impacting bounce rate`,
      data.metaDescription ? 'Meta description could be more compelling' : 'Missing meta description hurts SEO and click-through rates',
      data.hasCTA ? 'Call-to-action buttons could be more prominent' : 'No clear call-to-action to drive conversions'
    ];

    const fallbackIndustryCritiques = industry ? [
      `As a ${industry.specific} business, consider adding industry-specific trust signals`,
      `Review industry best practices for ${industry.specific} to improve conversions`
    ] : [];

    const fallbackSeoCritiques = seoResults ? [
      seoResults.sitemap.exists ? 'Consider submitting sitemap to Google Search Console' : 'Missing sitemap.xml - add one to help search engines discover pages',
      seoResults.imageAltTags.percentage > 50 ? `${seoResults.imageAltTags.percentage}% of images missing alt tags - hurts accessibility and SEO` : 'Review structured data markup for better search visibility'
    ] : [];

    const fallbackVisualCritiques = visualResults ? visualResults.critiques : [];
    const fallbackCompetitorCritiques = competitorResults ? competitorResults.critiques : [];

    return {
      companyName: new URL(url).hostname,
      critiques: fallbackCritiques,
      industryCritiques: fallbackIndustryCritiques,
      seoCritiques: fallbackSeoCritiques,
      visualCritiques: fallbackVisualCritiques,
      competitorCritiques: fallbackCompetitorCritiques,
      summary: 'Website has room for improvement in performance and conversion optimization',
      industry: industry,
      seo: seoResults,
      visual: visualResults,
      competitor: competitorResults
    };
  }
}

/**
 * Generate personalized email from critique
 */
function generateEmail(url, critique, emailType = 'local') {
  const { companyName, critiques, industryCritiques, seoCritiques, visualCritiques, competitorCritiques, summary, industry } = critique;
  const domain = new URL(url).hostname;

  // Simple templating helper - replace {{key}} with vars[key]
  function renderTemplate(template, vars = {}) {
    return template.replace(/\{\{(\w+)\}\}/g, (_, key) => {
      return vars[key] !== undefined ? String(vars[key]) : '';
    });
  }

  // Build industry-specific section if available
  let industrySection = '';
  if (industry && industryCritiques && industryCritiques.length > 0) {
    industrySection = `\n\nINDUSTRY-SPECIFIC ISSUES (${industry.specific}):\n${industryCritiques.map((c, i) => `${i + 1}. ${c}`).join('\n')}\n`;
  }

  // Build SEO section if available
  let seoSection = '';
  if (seoCritiques && seoCritiques.length > 0) {
    seoSection = `\n\nTECHNICAL SEO ISSUES:\n${seoCritiques.map((c, i) => `${i + 1}. ${c}`).join('\n')}\n`;
  }

  // Build visual design section if available
  let visualSection = '';
  if (visualCritiques && visualCritiques.length > 0) {
    visualSection = `\n\nVISUAL DESIGN ISSUES:\n${visualCritiques.map((c, i) => `${i + 1}. ${c}`).join('\n')}\n`;
  }

  // Build competitive analysis section if available
  let competitorSection = '';
  if (competitorCritiques && competitorCritiques.length > 0) {
    competitorSection = `\n\nCOMPETITIVE ANALYSIS:\n${competitorCritiques.map((c, i) => `${i + 1}. ${c}`).join('\n')}\n`;
  }

  const issueCount = critiques.length + (industryCritiques?.length || 0) + (seoCritiques?.length || 0) + (visualCritiques?.length || 0) + (competitorCritiques?.length || 0);

  // Default templates (keep concise and templated)
  const templates = {
    local: {
      subject: `{{issueCount}} quick improvements for {{domain}}`,
      body: `Hi {{firstName}},

{{opening}}

I took a quick look at {{domain}} and noticed a few issues worth addressing:

GENERAL ISSUES:
1. {{critique1}}
2. {{critique2}}
3. {{critique3}}{{industrySection}}{{seoSection}}{{visualSection}}{{competitorSection}}

{{summary}} These are all fixable, and we've helped similar organizations make these exact improvements.

Would you be open to a short 15-minute call to review a few concrete fixes? No obligation‚Äîjust useful feedback.

Best,
{{senderName}}
Co-Founder, Maksant
{{senderWebsite}}
{{senderPhone}}`
    },
    national: {
      subject: `Your website analysis ‚Äî {{domain}}`,
      body: `Hi {{firstName}},

{{opening}}

I analyzed {{domain}} and found a few areas for quick improvement:

GENERAL ISSUES:
1. {{critique1}}
2. {{critique2}}
3. {{critique3}}{{industrySection}}{{seoSection}}{{visualSection}}{{competitorSection}}

We've helped organizations like yours improve load times, conversions, and search visibility.

Would you be open to a 15-minute call to discuss low-effort wins we could implement?

Best regards,
{{senderName}}
Maksant
{{senderWebsite}}`
    }
  };

  // Variables for rendering
  const vars = {
    issueCount,
    domain,
    firstName: '{{firstName}}', // Proper placeholder format
    opening: (critique.humanizedEmail && critique.humanizedEmail.body)
      ? // Use the AI-provided body as a short opening if it's short; otherwise fall back to a one-line hook
        (critique.humanizedEmail.body.length < 300 ? critique.humanizedEmail.body.split('\n')[0] : '')
      : '',
    critique1: critiques[0] || '',
    critique2: critiques[1] || '',
    critique3: critiques[2] || '',
    industrySection: industrySection ? `\n\nINDUSTRY-SPECIFIC ISSUES (${industry ? industry.specific : ''}):\n${industryCritiques.map((c, i) => `${i + 1}. ${c}`).join('\n')}` : '',
    seoSection: seoSection ? `\n\nTECHNICAL SEO ISSUES:\n${seoCritiques.map((c, i) => `${i + 1}. ${c}`).join('\n')}` : '',
    visualSection: visualSection ? `\n\nVISUAL DESIGN ISSUES:\n${visualCritiques.map((c, i) => `${i + 1}. ${c}`).join('\n')}` : '',
    competitorSection: competitorSection ? `\n\nCOMPETITIVE ANALYSIS:\n${competitorCritiques.map((c, i) => `${i + 1}. ${c}`).join('\n')}` : '',
    summary: summary || '',
    senderName: '[Your Name]',
    senderWebsite: 'https://maksant.com'
  };

  const chosenTemplate = (emailType === 'local') ? templates.local : templates.national;

  // Allow subject override from AI if provided (still keep templated default)
  const subject = (critique.humanizedEmail && critique.humanizedEmail.subject)
    ? critique.humanizedEmail.subject
    : renderTemplate(chosenTemplate.subject, vars);

  // Render body template and fall back to AI-provided body if template yields empty
  let body = renderTemplate(chosenTemplate.body, vars);

  // If AI provided a full humanized email and the template feels insufficient, we can append or prefer it.
  if (critique.humanizedEmail && critique.humanizedEmail.body) {
    // If AI body is longer than template opening, append it after the template's opening line to keep template structure
    const aiBody = critique.humanizedEmail.body;
    if (aiBody.length > 120) {
      // Insert AI body after the opening paragraph if present
      const openingLine = vars.opening || '';
      if (openingLine) {
        body = body.replace(openingLine, openingLine + '\n\n' + aiBody);
      } else {
        // Append AI body at the top
        body = aiBody + '\n\n' + body;
      }
    }
  }

  return { subject, body };
}

/**
 * Analyze multiple websites one at a time with progress updates
 */
export async function analyzeWebsites(urls, options, sendProgress) {
  const browser = await chromium.launch({
    headless: true
  });

  const results = [];
  const emailType = options.emailType || 'local';
  const depthTier = options.depthTier || 'tier1';
  // Whether to run programmatic sanitization on AI text. Disabled by default unless options.useSanitizer === true or env USE_SANITIZER=true
  const useSanitizer = (options && options.useSanitizer !== undefined)
    ? options.useSanitizer
    : (process.env.USE_SANITIZER === 'true');

  // Determine sanitizer mode. Default to 'minimal' when sanitizer is enabled but mode not set.
  const sanitizerMode = (process.env.SANITIZER_MODE && process.env.SANITIZER_MODE.trim())
    ? process.env.SANITIZER_MODE.trim()
    : (useSanitizer ? 'minimal' : 'off');

  // Sender vars for placeholder replacement
  const senderNameEnv = process.env.SENDER_NAME || (() => {
    const m = (process.env.MAIL_FROM || '').replace(/"/g, '');
    if (!m) return '';
    return m.split('<')[0].trim();
  })();
  const senderPhoneEnv = process.env.SENDER_PHONE || '';
  const senderWebsiteEnv = process.env.SENDER_WEBSITE || '';

  // Create AI call tracker for cost estimation
  const aiTracker = new AICallTracker();
  
  // Estimate total AI calls
  const estimatedCallsPerSite = 1 + // critique generation
    (options.modules?.industry ? 0.5 : 0) + // industry detection (sometimes cached)
    (options.modules?.visual ? 1 : 0) + // visual analysis
    (options.modules?.competitor ? 2 : 0) + // competitor discovery + analysis
    (!options.skipHumanize ? 1 : 0); // email humanization
  
  const estimatedTotalCalls = Math.ceil(urls.length * estimatedCallsPerSite);
  const estimatedCostPerCall = aiTracker.estimateCost(options.textModel || 'gpt-5-mini');
  const estimatedTotalCost = estimatedTotalCalls * estimatedCostPerCall;
  
  // Send cost estimate before starting
  sendProgress({
    type: 'cost_estimate',
    estimatedCalls: estimatedTotalCalls,
    estimatedCost: estimatedTotalCost,
    message: `üí∞ Estimated: ${estimatedTotalCalls} AI calls (~$${estimatedTotalCost.toFixed(4)})`
  });

  try {
    // Process sites one at a time to show detailed progress
    for (let i = 0; i < urls.length; i++) {
      const url = urls[i];
      const siteNum = i + 1;

      // Send site start progress
      sendProgress({
        type: 'site_start',
        siteIndex: i,
        siteNum: siteNum,
        totalSites: urls.length,
        url,
        message: `üîç Analyzing ${url} (Site ${siteNum} of ${urls.length})`
      });

      try {
        // Track analysis start time
        const analysisStartTime = Date.now();

        // Step 1: Analyze homepage first
        const context = await browser.newContext({
          viewport: { width: 1920, height: 1080 },
          userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        });

        const page = await context.newPage();
        const homepageAnalysis = await analyzeWebsite(url, browser, sendProgress);

        // If homepage analysis failed, stop everything
        if (homepageAnalysis.error) {
          await page.close();
          await context.close();
          await browser.close();
          throw new Error(`Failed to analyze ${url}: ${homepageAnalysis.error}`);
        }

        // Step 2: Discover additional pages based on depth tier
        await page.goto(url, { waitUntil: 'domcontentloaded', timeout: 60000 });
        await page.waitForTimeout(2000); // Wait for dynamic content
        const pagesToAnalyze = await discoverPages(url, depthTier, page, sendProgress);
        await page.close();
        await context.close();

        // Step 3: Analyze additional pages (if Tier II or III)
        const allAnalyses = [homepageAnalysis];

        if (pagesToAnalyze.length > 1) {
          for (let pageIndex = 1; pageIndex < pagesToAnalyze.length; pageIndex++) {
            const pageUrl = pagesToAnalyze[pageIndex];

            sendProgress({
              type: 'step',
              step: 'analyzing_page',
              message: `‚è≥ Analyzing page ${pageIndex + 1} of ${pagesToAnalyze.length}...`,
              url
            });

            const pageAnalysis = await analyzeWebsite(pageUrl, browser, sendProgress);

            if (pageAnalysis.error) {
              sendProgress({
                type: 'step',
                step: 'page_failed',
                message: `‚ö†Ô∏è Skipped page ${pageIndex + 1} (failed to load)`,
                url
              });
            } else {
              allAnalyses.push(pageAnalysis);

              sendProgress({
                type: 'step',
                step: 'page_analyzed',
                message: `‚úì Page ${pageIndex + 1} of ${pagesToAnalyze.length} analyzed`,
                url
              });
            }
          }
        }

        // Step 4: Combine analyses from all pages
        const combinedAnalysis = combineMultiPageAnalyses(allAnalyses);

        // Step 4.1: Aggregate contact info from page-level extractions
        const pageContactResults = allAnalyses.map(a => a.contact || { pageUrl: a.url, emails: [], phones: [], names: [], contactPages: [] });
        const bestContact = findBestContact(url, pageContactResults);

        sendProgress({
          type: 'step',
          step: 'contact_discovery_complete',
          message: `‚úì Contact discovery complete${bestContact ? ` (found ${bestContact.email})` : ' (no email found)'}`,
          url
        });

        // Step 5: Detect industry (if module enabled)
        let industry = null;
        if (options.modules?.industry) {
          industry = await detectIndustry(combinedAnalysis, options.textModel, sendProgress);
        }

        // Step 6: Run SEO audit (if module enabled)
        let seoResults = null;
        if (options.modules?.seo) {
          // Need to reopen page for SEO audit
          const seoContext = await browser.newContext({
            viewport: { width: 1920, height: 1080 },
            userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
          });
          const seoPage = await seoContext.newPage();
          await seoPage.goto(url, { waitUntil: 'networkidle', timeout: 30000 });
          seoResults = await runSEOAudit(seoPage, url, sendProgress);
          await seoPage.close();
          await seoContext.close();
        }

        // Step 7: Analyze visual design (if module enabled)
        let visualResults = null;
        if (options.modules?.visual) {
          // Collect all screenshot paths from all pages analyzed
          const allScreenshots = allAnalyses
            .filter(a => !a.error && a.screenshotPath)
            .map(a => ({
              url: a.url,
              screenshotPath: a.screenshotPath
            }));

          visualResults = await analyzeVisualDesign(
            allScreenshots,
            options.visionModel,
            sendProgress,
            url
          );
        }

        // Step 8: Discover and analyze competitors (if module enabled)
        let competitorResults = null;
        if (options.modules?.competitor && industry) {
          competitorResults = await discoverAndAnalyzeCompetitors(
            combinedAnalysis,
            industry,
            options.textModel,
            depthTier,
            browser,
            sendProgress,
            url
          );
        }

        // Step 9: Calculate quality grade (needed for email personalization)
        const grokData = homepageAnalysis.grokData;
        const hasEmail = !!(grokData?.contactInfo?.email || bestContact?.email);
        const hasPhone = !!(grokData?.contactInfo?.phone || bestContact?.phone);
        let qualityScore = 0;
        let qualityGrade = 'F';

        if (hasEmail || hasPhone) {
          if (hasEmail) qualityScore += 30;
          if (hasPhone) qualityScore += 20;
          if (grokData?.companyInfo?.name) qualityScore += 10;
          if (grokData?.companyInfo?.industry) qualityScore += 10;
          if (grokData?.companyInfo?.location) qualityScore += 5;
          if (grokData?.businessIntel?.services?.length > 0) qualityScore += 10;
          if (grokData?.businessIntel?.valueProposition) qualityScore += 5;

          const socialCount = [
            grokData?.socialProfiles?.linkedIn?.company,
            grokData?.socialProfiles?.instagram?.url,
            grokData?.socialProfiles?.twitter?.url,
            grokData?.socialProfiles?.facebook,
            grokData?.socialProfiles?.youtube
          ].filter(Boolean).length;
          if (socialCount > 0) qualityScore += 10;

          if (qualityScore >= 70) qualityGrade = 'A';
          else if (qualityScore >= 50) qualityGrade = 'B';
          else if (qualityScore >= 30) qualityGrade = 'C';
          else if (qualityScore >= 1) qualityGrade = 'D';
        }

        // Step 10: Generate critique (with all module context if available)
        const critique = await generateCritique(combinedAnalysis, industry, seoResults, visualResults, competitorResults, sendProgress, { ...options, aiTracker });

        // Step 10: Generate email
        sendProgress({
          type: 'step',
          step: 'generating_email',
          message: `‚è≥ Generating email template...`,
          url
        });

        let email = generateEmail(url, critique, emailType);

        // Extract contact info from the main website analysis (for placeholder replacement and results)
        const contactInfo = extractContactInfo(combinedAnalysis);
        
        // Replace placeholders BEFORE humanization so the AI sees real values
        const domain = new URL(url).hostname;
        
        // Smart fallback: firstName > companyName > "there"
        let firstName = (bestContact && bestContact.firstName) || contactInfo.firstName;
        if (!firstName) {
          // Use company name as fallback (e.g., "Hi Maksant team")
          firstName = critique.companyName ? `${critique.companyName} team` : 'there';
        }
        
        // Always replace placeholders in the template first
        email = replacePlaceholders(email, {
          senderName: senderNameEnv,
          senderPhone: senderPhoneEnv,
          senderWebsite: senderWebsiteEnv,
          domain: domain,
          firstName: firstName
        });

        // Optionally humanize the email with AI (now it has real values, not placeholders)
        if (!options.skipHumanize) {
          try {
            // Pass ALL context for personalization (Grok data, industry, modules, etc.)
            const personalizationContext = {
              grokData: homepageAnalysis.grokData,
              industry: industry,
              hasVisualAnalysis: !!visualResults,
              hasSEOAnalysis: !!seoResults,
              hasCompetitorAnalysis: !!competitorResults,
              pagesAnalyzed: allAnalyses.length,
              depthTier: depthTier,
              qualityScore: qualityScore,  // NEW: Include quality score
              qualityGrade: qualityGrade   // NEW: Include quality grade
            };

            const humanized = await humanizeEmailWithAI(email, critique, {
              ...options,
              aiTracker,
              personalizationContext
            });
            email = humanized;

          } catch (e) {
            console.error('Email humanization failed:', e.message);
            // Keep templated email
          }
        }

        // Apply sanitizer if enabled (for aggressive filtering)
        if (useSanitizer && sanitizerMode === 'full') {
          const sanitized = sanitizeHumanizedEmail(email);
          email = sanitized;
        }

        // QA Review Agent - Validate email quality before saving
        let qaReview = null;
        if (!options.skipQA && email) {
          try {
            sendProgress({
              type: 'step',
              step: 'qa_review',
              message: `‚è≥ Running QA review...`,
              url
            });

            // Build modulesUsed for QA context
            const qaModulesUsed = ['basic'];
            if (industry) qaModulesUsed.push('industry');
            if (seoResults) qaModulesUsed.push('seo');
            if (visualResults) qaModulesUsed.push('visual');
            if (competitorResults) qaModulesUsed.push('competitor');

            qaReview = await qaReviewEmail(email, {
              modulesUsed: qaModulesUsed,
              hasVisualAnalysis: !!visualResults,
              contact: bestContact,
              grokData: grokData,
              companyName: critique.companyName
            }, {
              ...options,
              aiTracker
            });

            sendProgress({
              type: 'step',
              step: 'qa_complete',
              message: `‚úì QA review: Lead Grade ${qaReview.leadGrade} - ${qaReview.summary}`,
              url
            });

            // Log QA issues if any
            if (qaReview.issues && qaReview.issues.length > 0) {
              console.warn(`QA issues found for ${url}:`, qaReview.issues);
            }

          } catch (e) {
            console.error('QA review failed:', e.message);
            qaReview = {
              passed: true,
              grade: 'B',
              issues: [],
              warnings: [`QA review error: ${e.message}`],
              suggestions: [],
              summary: 'QA review encountered an error'
            };
          }
        }

        // Optionally save to Gmail Drafts if requested in options
        let draftResult = null;
        if (options.saveToDrafts) {
          try {
            // Get email from multiple sources (priority order)
            const recipient = (bestContact && bestContact.email) ||
                            grokData?.contactInfo?.email ||
                            contactInfo?.emails?.[0]?.value ||
                            'replace-me@example.com';

            const from = process.env.MAIL_FROM || 'Maksant <no-reply@maksant.com>';
            const html = email.body.replace(/\n/g, '<br>');

            const isDry = options.dryRun || process.env.DRY_RUN === 'true';
            if (isDry) {
              console.log('[DRY_RUN] Would create draft to', recipient, 'subject:', email.subject);
              draftResult = { dryRun: true, wouldSendTo: recipient, subject: email.subject };
            } else {
              draftResult = await createDraft({
                from,
                to: recipient,
                subject: email.subject,
                text: email.body,
                html
              });
            }
          } catch (err) {
            console.error('Failed to save Gmail draft:', err.message);
            draftResult = { error: err.message };
          }
        }

        sendProgress({
          type: 'step',
          step: 'email_generated',
          message: `‚úì Email template generated`,
          url
        });

        // Add result
        const modulesUsed = ['basic'];
        if (industry) {
          modulesUsed.push('industry');
        }
        if (seoResults) {
          modulesUsed.push('seo');
        }
        if (visualResults) {
          modulesUsed.push('visual');
        }
        if (competitorResults) {
          modulesUsed.push('competitor');
        }

        // Calculate elapsed time
        const analysisTime = Math.round((Date.now() - analysisStartTime) / 1000); // seconds

        // Calculate actual cost based on what ran
        const costBreakdown = {
          grokModel: 'grok-beta',
          textModel: options.textModel || 'gpt-5-mini',
          visionModel: options.visionModel || 'gpt-4o',
          cheapModel: 'gpt-4o-mini',

          grokExtraction: true,  // Always runs
          basicAnalysis: true,   // Always runs
          industryAnalysis: !!industry,
          seoAnalysis: !!seoResults,
          visualAnalysis: visualResults ? visualResults.screenshots?.length || 0 : 0,
          competitorAnalysis: !!competitorResults,
          emailWriting: true,    // Always runs
          critiqueReasoning: true,  // Always runs
          qaReview: true,        // Always runs

          pagesAnalyzed: allAnalyses.length,
        };

        const { totalCost, breakdown: costDetails } = calculateTotalCost(costBreakdown);

        const result = {
          url,
          companyName: critique.companyName,
          contact: bestContact || null,
          extractedContact: contactInfo, // Add extracted contact info
          grokData: homepageAnalysis.grokData || null, // NEW: Include full Grok extraction data
          critiques: {
            basic: critique.critiques,
            industry: critique.industryCritiques || [],
            seo: critique.seoCritiques || [],
            visual: critique.visualCritiques || [],
            competitor: critique.competitorCritiques || []
          },
          industry: critique.industry,
          seo: critique.seo,
          visual: critique.visual,
          competitor: critique.competitor,
          summary: critique.summary,
          email: email,
          emailQA: qaReview || null, // QA review of email quality
          draft: draftResult,
          loadTime: homepageAnalysis.loadTime,
          screenshot: homepageAnalysis.screenshotPath,
          pagesAnalyzed: allAnalyses.length,
          modulesUsed: modulesUsed,
          cost: totalCost,  // Actual cost in dollars
          costBreakdown: costDetails,  // Cost per operation
          analysisTime: analysisTime,  // Elapsed time in seconds
          metadata: options.metadata || null,  // Multi-tenant tracking (projectId, campaignId, clientName, sourceApp)
          error: null
        };

        // Generate critique reasoning (using cheap model) for user reference
        // This must happen AFTER result object is created
        if (!options.skipHumanize && email) {
          try {
            const personalizationContext = {
              grokData: homepageAnalysis.grokData,
              industry: industry,
              hasVisualAnalysis: !!visualResults,
              hasSEOAnalysis: !!seoResults,
              hasCompetitorAnalysis: !!competitorResults,
              pagesAnalyzed: allAnalyses.length,
              depthTier: depthTier,
              qualityScore: qualityScore,
              qualityGrade: qualityGrade
            };

            const reasoning = await generateCritiqueReasoning(email, critique, personalizationContext, {
              ...options,
              aiTracker
            });
            result.critiqueReasoning = reasoning;
          } catch (e) {
            console.error('Critique reasoning generation failed:', e.message);
            result.critiqueReasoning = 'Reasoning generation failed';
          }
        }

        results.push(result);

        // Save analysis results to folder
        const savedPath = await saveAnalysisResults(result);
        if (savedPath) {
          result.savedPath = savedPath; // Add path to result object
        }

        // Save to Supabase database (if enabled and configured)
        if (options.saveToSupabase !== false) {  // Default true if not specified
          try {
            await saveLeadToSupabase(result);
          } catch (error) {
            console.error(`‚ùå Failed to save to Supabase:`, error.message);
            // Don't fail the whole analysis if Supabase is down
          }
        } else {
          console.log('‚è≠Ô∏è  Supabase saving disabled by user');
        }

        // Send site complete progress
        sendProgress({
          type: 'site_complete',
          siteIndex: i,
          siteNum: siteNum,
          totalSites: urls.length,
          url,
          message: `‚úÖ Site ${siteNum} complete! (${allAnalyses.length} pages analyzed)${savedPath ? ` | Saved to: ${savedPath}` : ''}`
        });

      } catch (siteError) {
        // If any site fails, stop everything
        await browser.close();
        throw siteError;
      }
    }

    // Send final cost summary
    const costSummary = aiTracker.getSummary();
    sendProgress({
      type: 'cost_summary',
      totalCalls: costSummary.totalCalls,
      totalCost: costSummary.estimatedCost,
      totalInputTokens: costSummary.totalInputTokens,
      totalOutputTokens: costSummary.totalOutputTokens,
      message: `‚úÖ Analysis complete: ${costSummary.totalCalls} AI calls, $${costSummary.estimatedCost.toFixed(4)} total cost`
    });

    await browser.close();
    return results;

  } catch (error) {
    await browser.close();
    throw error;
  }
}

/**
 * Combine analyses from multiple pages into one
 */
function combineMultiPageAnalyses(analyses) {
  // Use the first (homepage) analysis as base
  const combined = { ...analyses[0] };

  if (analyses.length === 1) {
    return combined;
  }

  // Aggregate data from all pages
  let totalLoadTime = 0;
  let allH1Tags = [];
  let totalImages = 0;
  let totalLinks = 0;
  let allBodyText = '';

  analyses.forEach((analysis, index) => {
    if (!analysis.error && analysis.data) {
      totalLoadTime += analysis.loadTime;
      allH1Tags.push(...(analysis.data.h1Tags || []));
      totalImages += analysis.data.imageCount || 0;
      totalLinks += analysis.data.linkCount || 0;
      allBodyText += analysis.data.bodyText || '';
    }
  });

  // Update combined data
  combined.loadTime = Math.round(totalLoadTime / analyses.length); // Average load time
  combined.data = {
    ...combined.data,
    h1Tags: allH1Tags.slice(0, 10), // Top 10 H1s from all pages
    imageCount: totalImages,
    linkCount: totalLinks,
    bodyText: allBodyText.slice(0, 8000), // More content from multiple pages (homepage + services + contact)
    pagesAnalyzed: analyses.length
  };

  return combined;
}
